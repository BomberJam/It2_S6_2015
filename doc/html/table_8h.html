<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Projet Informatique Théorique 2015: Référence du fichier table.h</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Projet Informatique Théorique 2015
   </div>
   <div id="projectbrief">Instructions et Documentation</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Généré par Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Recherche');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Page&#160;principale</span></a></li>
      <li><a href="pages.html"><span>Pages&#160;associées</span></a></li>
      <li><a href="annotated.html"><span>Structures&#160;de&#160;données</span></a></li>
      <li class="current"><a href="files.html"><span>Fichiers</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Recherche" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>Liste&#160;des&#160;fichiers</span></a></li>
      <li><a href="globals.html"><span>Variables&#160;globales</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Définitions de type</a> &#124;
<a href="#func-members">Fonctions</a>  </div>
  <div class="headertitle">
<div class="title">Référence du fichier table.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &quot;avl.h&quot;</code><br />
</div>
<p><a href="table_8h_source.html">Aller au code source de ce fichier.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Définitions de type</h2></td></tr>
<tr class="memitem:aaa5713bb2ecdf81c430009179b806232"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_table.html">Table</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#aaa5713bb2ecdf81c430009179b806232">Table</a></td></tr>
<tr class="memdesc:aaa5713bb2ecdf81c430009179b806232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Définit le type d'une table.  <a href="#aaa5713bb2ecdf81c430009179b806232">Plus de détails...</a><br /></td></tr>
<tr class="separator:aaa5713bb2ecdf81c430009179b806232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6278d7df5951aa5f48522a0d279c68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5c6278d7df5951aa5f48522a0d279c68"></a>
typedef struct <a class="el" href="structavl__traverser.html">avl_traverser</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a></td></tr>
<tr class="memdesc:a5c6278d7df5951aa5f48522a0d279c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Définit le type d'un itérateur sur les éléments d'une table. <br /></td></tr>
<tr class="separator:a5c6278d7df5951aa5f48522a0d279c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Fonctions</h2></td></tr>
<tr class="memitem:a552c5a1dc843f876d6dbaf74da05e063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_table.html">Table</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a552c5a1dc843f876d6dbaf74da05e063">creer_table</a> (int(*comparer_cle)(const intptr_t cle1, const intptr_t cle2), intptr_t(*copier_cle)(const intptr_t cle), void(*supprimer_cle)(intptr_t cle))</td></tr>
<tr class="memdesc:a552c5a1dc843f876d6dbaf74da05e063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie une nouvelle table.  <a href="#a552c5a1dc843f876d6dbaf74da05e063">Plus de détails...</a><br /></td></tr>
<tr class="separator:a552c5a1dc843f876d6dbaf74da05e063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ef78c123bff3d47f64013579bdde72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a88ef78c123bff3d47f64013579bdde72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a88ef78c123bff3d47f64013579bdde72">liberer_table</a> (<a class="el" href="struct_table.html">Table</a> *table)</td></tr>
<tr class="memdesc:a88ef78c123bff3d47f64013579bdde72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cette fonction détruit une table. La mémoire qui a été allouée par la table pour stocker les clés sont aussi détruites. Attention, la table ne gère pas la mémoire associée aux valeurs. C'est à l'utilisateur de détruire proprement les valeurs. <br /></td></tr>
<tr class="separator:a88ef78c123bff3d47f64013579bdde72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b3ec6f4ab208a6ed1176231c7e3b63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63">add_table</a> (<a class="el" href="struct_table.html">Table</a> *table, const intptr_t cle, const intptr_t valeur)</td></tr>
<tr class="memdesc:ac9b3ec6f4ab208a6ed1176231c7e3b63"><td class="mdescLeft">&#160;</td><td class="mdescRight">La fonction <a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63" title="La fonction add_table() ajoute une association entre une clé et une valeur. Pour cela, add_table(), crée une copie de la clé passée en paramètre, l&#39;enregistre dans la table et l&#39;associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l&#39;utilisateur. ">add_table()</a> ajoute une association entre une clé et une valeur. Pour cela, <a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63" title="La fonction add_table() ajoute une association entre une clé et une valeur. Pour cela, add_table(), crée une copie de la clé passée en paramètre, l&#39;enregistre dans la table et l&#39;associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l&#39;utilisateur. ">add_table()</a>, crée une copie de la clé passée en paramètre, l'enregistre dans la table et l'associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l'utilisateur.  <a href="#ac9b3ec6f4ab208a6ed1176231c7e3b63">Plus de détails...</a><br /></td></tr>
<tr class="separator:ac9b3ec6f4ab208a6ed1176231c7e3b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b87338b43e9972889d02e0364b52cf4"><td class="memItemLeft" align="right" valign="top">intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a2b87338b43e9972889d02e0364b52cf4">delete_table</a> (<a class="el" href="struct_table.html">Table</a> *table, const intptr_t cle)</td></tr>
<tr class="memdesc:a2b87338b43e9972889d02e0364b52cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supprime une clé de la table. La mémoire de la clé est libérée et la valeur associée à la clé est perdue.  <a href="#a2b87338b43e9972889d02e0364b52cf4">Plus de détails...</a><br /></td></tr>
<tr class="separator:a2b87338b43e9972889d02e0364b52cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972c5e361ad057d3db95b1e1bd7f39ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a972c5e361ad057d3db95b1e1bd7f39ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a972c5e361ad057d3db95b1e1bd7f39ad">vider_table</a> (<a class="el" href="struct_table.html">Table</a> *table)</td></tr>
<tr class="memdesc:a972c5e361ad057d3db95b1e1bd7f39ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supprime toutes les clés de la table. <br /></td></tr>
<tr class="separator:a972c5e361ad057d3db95b1e1bd7f39ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdd9232570ac86205eaa7fa0dedb858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#afcdd9232570ac86205eaa7fa0dedb858">print_table</a> (<a class="el" href="struct_table.html">Table</a> *table, void(*print_cle)(const intptr_t cle), void(*print_valeur)(const intptr_t valeur), const char *text_de_fin)</td></tr>
<tr class="memdesc:afcdd9232570ac86205eaa7fa0dedb858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affiche la table. Vous devez donner en paramètres de print_table, des fonctions pour afficher les clés et les valeurs.  <a href="#afcdd9232570ac86205eaa7fa0dedb858">Plus de détails...</a><br /></td></tr>
<tr class="separator:afcdd9232570ac86205eaa7fa0dedb858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df917b1645531aa0703225badb2eb69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a3df917b1645531aa0703225badb2eb69">pour_toute_valeur_table</a> (const <a class="el" href="struct_table.html">Table</a> *table, void(*action)(intptr_t valeur))</td></tr>
<tr class="memdesc:a3df917b1645531aa0703225badb2eb69"><td class="mdescLeft">&#160;</td><td class="mdescRight">La fonction passe en revue toutes les valeurs de la table passée en paramètre et apelle la fonction passée en paramètre pour chacune des valeur parcourues. Une valeur est parcourue autant de fois qu'elle apparaît dans la table, et la fonction est executée autant de fois que la valeur apparaît.  <a href="#a3df917b1645531aa0703225badb2eb69">Plus de détails...</a><br /></td></tr>
<tr class="separator:a3df917b1645531aa0703225badb2eb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d7df224d07e74585e52e90039bee6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a79d7df224d07e74585e52e90039bee6a">pour_toute_cle_valeur_table</a> (const <a class="el" href="struct_table.html">Table</a> *table, void(*action)(const intptr_t cle, intptr_t valeur, void *data), void *data)</td></tr>
<tr class="memdesc:a79d7df224d07e74585e52e90039bee6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">La fonction passe en revue toutes les associaitons (clé, valeur) de la table, et apelle la fonction passée en paramètre pour chasune de ces associations.  <a href="#a79d7df224d07e74585e52e90039bee6a">Plus de détails...</a><br /></td></tr>
<tr class="separator:a79d7df224d07e74585e52e90039bee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf43dc2cdf9618b0b683e7697fcc7c1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf43dc2cdf9618b0b683e7697fcc7c1"></a>
<a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#acaf43dc2cdf9618b0b683e7697fcc7c1">trouver_table</a> (const <a class="el" href="struct_table.html">Table</a> *table, const intptr_t cle)</td></tr>
<tr class="memdesc:acaf43dc2cdf9618b0b683e7697fcc7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie un itérateur positionné sur l'association dont la clé est identique (pour la fonction de comparaison de clé de la table) à la clé passée en paramètre. <br /></td></tr>
<tr class="separator:acaf43dc2cdf9618b0b683e7697fcc7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e421aa4c8f62eeda45e7bc3736f3933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a9e421aa4c8f62eeda45e7bc3736f3933">premier_iterateur_table</a> (const <a class="el" href="struct_table.html">Table</a> *table)</td></tr>
<tr class="memdesc:a9e421aa4c8f62eeda45e7bc3736f3933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie un itérateur positionné sur la première association de la table.  <a href="#a9e421aa4c8f62eeda45e7bc3736f3933">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9e421aa4c8f62eeda45e7bc3736f3933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c7763f32c545fec672404d132792b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#aa1c7763f32c545fec672404d132792b7">iterateur_suivant_table</a> (<a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> iterator)</td></tr>
<tr class="memdesc:aa1c7763f32c545fec672404d132792b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie l'itérateur suivant.  <a href="#aa1c7763f32c545fec672404d132792b7">Plus de détails...</a><br /></td></tr>
<tr class="separator:aa1c7763f32c545fec672404d132792b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9603ef84d6e9a24098b62e77b42b95fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a9603ef84d6e9a24098b62e77b42b95fe">iterateur_precedent_table</a> (<a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> iterator)</td></tr>
<tr class="memdesc:a9603ef84d6e9a24098b62e77b42b95fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie l'itérateur précédent.  <a href="#a9603ef84d6e9a24098b62e77b42b95fe">Plus de détails...</a><br /></td></tr>
<tr class="separator:a9603ef84d6e9a24098b62e77b42b95fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee072a7c020addb0bc7ab9d853cc7ba6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee072a7c020addb0bc7ab9d853cc7ba6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#aee072a7c020addb0bc7ab9d853cc7ba6">iterateur_est_vide</a> (<a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> iterator)</td></tr>
<tr class="memdesc:aee072a7c020addb0bc7ab9d853cc7ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie 1 si l'itérateur passé en paramètre est vide. Renvoie 0 sinon. <br /></td></tr>
<tr class="separator:aee072a7c020addb0bc7ab9d853cc7ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f28753b8622c30af050bb9da5b804fd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5f28753b8622c30af050bb9da5b804fd"></a>
intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a5f28753b8622c30af050bb9da5b804fd">get_cle</a> (<a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> it)</td></tr>
<tr class="memdesc:a5f28753b8622c30af050bb9da5b804fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la clé de l'association pointée par l'itérateur passé en paramètre. <br /></td></tr>
<tr class="separator:a5f28753b8622c30af050bb9da5b804fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb03479e969e37adbf216248ded15d7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb03479e969e37adbf216248ded15d7"></a>
intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#a7eb03479e969e37adbf216248ded15d7">get_valeur</a> (<a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> it)</td></tr>
<tr class="memdesc:a7eb03479e969e37adbf216248ded15d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la valeur de l'association pointée par l'itérateur passé en paramètre. <br /></td></tr>
<tr class="separator:a7eb03479e969e37adbf216248ded15d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af421529230da9bb2fb415e75568afba8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af421529230da9bb2fb415e75568afba8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="table_8h.html#af421529230da9bb2fb415e75568afba8">taille_table</a> (<a class="el" href="struct_table.html">Table</a> *t)</td></tr>
<tr class="memdesc:af421529230da9bb2fb415e75568afba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renvoie la taille de la table. <br /></td></tr>
<tr class="separator:af421529230da9bb2fb415e75568afba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Documentation des définitions de type</h2>
<a class="anchor" id="aaa5713bb2ecdf81c430009179b806232"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_table.html">Table</a> <a class="el" href="struct_table.html">Table</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Définit le type d'une table. </p>
<p>Une table est une structure de donnée qui associe une clé à une et une seule valeur.</p>
<p>Une table ne peut pas contenir deux fois la même clé. Par contre, à deux clés différentes, on peut assicer deux fois la même valeur. </p>

<p>Définition à la ligne <a class="el" href="table_8h_source.html#l00037">37</a> du fichier <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Documentation des fonctions</h2>
<a class="anchor" id="a552c5a1dc843f876d6dbaf74da05e063"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_table.html">Table</a>* creer_table </td>
          <td>(</td>
          <td class="paramtype">int(*)(const intptr_t cle1, const intptr_t cle2)&#160;</td>
          <td class="paramname"><em>comparer_cle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t(*)(const intptr_t cle)&#160;</td>
          <td class="paramname"><em>copier_cle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(intptr_t cle)&#160;</td>
          <td class="paramname"><em>supprimer_cle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie une nouvelle table. </p>
<p>La clé et la valeur peuvent être des entiers ou bien des structures plus compliquées.</p>
<p>La mémoire associée à la clé est gérée par la table, alors que celle de la valeur est laissée à la charge de l'utilisateur. C'est pourquoi, à la création de la table, il faut donner des pointeurs de fonctions à la table pour lui permettre de copier, supprimer et comparer des clés. Si vous choisissez d'utiliser des entiers pour coder la clé, vous pouvez mettre tous les paramètres 'comparer_cle', 'copier_cle' et 'supprimer_cle' à NULL. En effet, dans ce cas, la table se chargera d'utiliser ses propres fonctions pour copier et comparer les clés. </p><hr/>
 <h1>Exemple 1 </h1>
<p>Voici un exemple qui</p><ul>
<li>crée une table qui, à un entier, associe un entier.</li>
<li>affiche la table en utilisant des itérateurs.</li>
</ul>
<p><a class="el" href="struct_table.html">Table</a> * table = creer_table( NULL, NULL, NULL );</p>
<p>add_table( table, 1, 2 ); add_table( table, 2, 30 );</p>
<p>Table_iterateur it; for( it = premier_iterateur_table( table ); ! iterateur_est_vide( it ); it = iterateur_suivant_table( it ) ){ printf( "cle : %d -&gt; valeur : %d \n", get_cle( it ), get_valeur( it ) ); }</p>
<p>liberer_table( t )</p>
<hr/>
 <h1>Exemple 2 </h1>
<p>Dans cet exemple, nous montrons comment associer un entier à un couple</p>
<p>typdef struct { int x; int y; } Couple; // On définit le couple</p>
<p><a class="el" href="struct_table.html">Table</a> * t = creer_table( NULL; NULL, NULL ); // On crée la table</p>
<p>Couple * c = malloc( sizeof(Couple) ): // On crée une valeur c.x = 1; c.y=2;</p>
<p>add_table( t,(intptr_t) c ); // On ajoute la valeur dans la table</p>
<p>... // On utilise la table</p>
<p>pour_toute_valeur_table( t, free ) // On détruit les valeurs // La mémoire des valeurs n'est pas // gérée par la table ! liberer_table( t ); // On détruit la table </p><hr/>
 <h1>Exemple 3 </h1>
<p>Voici maintenant un exemple de table où l'on associe un couple à un entier</p>
<p>typdef struct { int x; int y; } Couple; // On définit la clé</p>
<p>int comparer_couple( Couple* c1, Couple* c2 ){ if( c1.x == c2.x ) return c1.y -c2.y; return c1.x - c2.x; }</p>
<p>Couple* copier_couple( const Couple* c ){ Couple * res = malloc( sizeof(Couple) ); res.x = c-&gt;x; res.y = c-&gt;y; return res; }</p>
<p>void supprimer_couple( Couple* c ){ free( c ); }</p>
<p>typdef struct { int x; int y; } Couple; // On définit le couple</p>
<p><a class="el" href="struct_table.html">Table</a> * table = creer_table( // On crée la table ( void(*)( const intptr_t, const intptr_t) ) comparer_couple, ( void(*)( const intptr_t ) ) copier_couple, ( void(*)( intptr_t ) ) supprimer_couple );</p>
<p>Couple c; c.x = 3; c.y = 4;</p>
<p>add_table( table, (intptr_t) &amp;c, 4 ); // On ajoute l'associaiton (3,4) &ndash;&gt; 4</p>
<p>... // On utilise la table</p>
<p>liberer_table( table ); // On détruit la table </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00117">117</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac9b3ec6f4ab208a6ed1176231c7e3b63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_table.html">Table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const intptr_t&#160;</td>
          <td class="paramname"><em>cle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const intptr_t&#160;</td>
          <td class="paramname"><em>valeur</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La fonction <a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63" title="La fonction add_table() ajoute une association entre une clé et une valeur. Pour cela, add_table(), crée une copie de la clé passée en paramètre, l&#39;enregistre dans la table et l&#39;associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l&#39;utilisateur. ">add_table()</a> ajoute une association entre une clé et une valeur. Pour cela, <a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63" title="La fonction add_table() ajoute une association entre une clé et une valeur. Pour cela, add_table(), crée une copie de la clé passée en paramètre, l&#39;enregistre dans la table et l&#39;associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l&#39;utilisateur. ">add_table()</a>, crée une copie de la clé passée en paramètre, l'enregistre dans la table et l'associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l'utilisateur. </p>
<p>Dans une table, il ne peut pas y avoir deux clés identiques en même temps. Si la clé passée en paramètre à <a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63" title="La fonction add_table() ajoute une association entre une clé et une valeur. Pour cela, add_table(), crée une copie de la clé passée en paramètre, l&#39;enregistre dans la table et l&#39;associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l&#39;utilisateur. ">add_table()</a> existe déjà dans la table, alors, l'ancienne valeur associée à la clé est remplacée par la nouvelle passée en paramètre à <a class="el" href="table_8h.html#ac9b3ec6f4ab208a6ed1176231c7e3b63" title="La fonction add_table() ajoute une association entre une clé et une valeur. Pour cela, add_table(), crée une copie de la clé passée en paramètre, l&#39;enregistre dans la table et l&#39;associe à la valeur passée en paramètre. La mémoire de la copie de la clé est gérée par la table. La mémoire de la clé passée en paramètre reste à la charge de l&#39;utilisateur. ">add_table()</a>. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00137">137</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2b87338b43e9972889d02e0364b52cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t delete_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_table.html">Table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const intptr_t&#160;</td>
          <td class="paramname"><em>cle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Supprime une clé de la table. La mémoire de la clé est libérée et la valeur associée à la clé est perdue. </p>
<p>Si la valeur contenait un pointeur vers un espace mémoire, cette mémoire n'est <b>PAS</b> libérée ! Sa gestion est laissée à la charge de l'utilisateur. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00150">150</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="afcdd9232570ac86205eaa7fa0dedb858"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_table.html">Table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const intptr_t cle)&#160;</td>
          <td class="paramname"><em>print_cle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const intptr_t valeur)&#160;</td>
          <td class="paramname"><em>print_valeur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text_de_fin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Affiche la table. Vous devez donner en paramètres de print_table, des fonctions pour afficher les clés et les valeurs. </p>
<p>Si les clés ou les valeurs sont des entiers, vous pouvez ne pas donner ces fonctions en remplissant les champs par le pointeur vide : NULL . </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00227">227</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3df917b1645531aa0703225badb2eb69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pour_toute_valeur_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_table.html">Table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(intptr_t valeur)&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La fonction passe en revue toutes les valeurs de la table passée en paramètre et apelle la fonction passée en paramètre pour chacune des valeur parcourues. Une valeur est parcourue autant de fois qu'elle apparaît dans la table, et la fonction est executée autant de fois que la valeur apparaît. </p>
<p>La fonction qui sera executée (et qui a été passée en paramètre), doit posséder l'entête suivante : void NON_FONCTION( intptr_t valeur, void* data  ), void NON_FONCTION( const intptr_t cle, intptr_t valeur, void* data  ), Le pramètre 'valeur' correspond à la valeur qui est en train d'être parcouru. Le paramètre 'data' est un pointeur qui sera identique à celui passé par le paramètre 'data' de la fonction <a class="el" href="automate_8h.html#a8be2c289a8f2075d1bf8090dee1afcf0" title="La fonction passe en revue toutes les transitions de l&#39;automate et appelle la fonction passée en para...">pour_toute_transition()</a>. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00192">192</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="a79d7df224d07e74585e52e90039bee6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pour_toute_cle_valeur_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_table.html">Table</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(const intptr_t cle, intptr_t valeur, void *data)&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>La fonction passe en revue toutes les associaitons (clé, valeur) de la table, et apelle la fonction passée en paramètre pour chasune de ces associations. </p>
<p>La fonction qui sera executée (et qui a été passée en paramètre), doit posséder l'entête suivante : void NON_FONCTION( const intptr_t cle, intptr_t valeur, void* data  ), Les pramètres 'cle et 'valeur' correspondent à la clé et la valeur de l'association qui est en train d'être parcouru. Le paramètre 'data' est un pointeur qui sera identique à celui passé par le paramètre 'data' de la fonction <a class="el" href="automate_8h.html#a8be2c289a8f2075d1bf8090dee1afcf0" title="La fonction passe en revue toutes les transitions de l&#39;automate et appelle la fonction passée en para...">pour_toute_transition()</a>. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00169">169</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9e421aa4c8f62eeda45e7bc3736f3933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> premier_iterateur_table </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_table.html">Table</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie un itérateur positionné sur la première association de la table. </p>
<p>Deux associations sont comparer en comparant leurs clés et la fonction de comparaison des clés de la table. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00251">251</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa1c7763f32c545fec672404d132792b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> iterateur_suivant_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a>&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie l'itérateur suivant. </p>
<p>C'est-à-dire, l'itérateur renvoyé est positionné sur une nouvelle association qui est la plus petite des associations plus grandes que celle associée à l'itérateur passé en en paramètre.</p>
<p>Deux associations sont comparées en comparant leurs clés et la fonction de comparaison des clés de la table.</p>
<p>S'il n'y a pas d'itérateur suivant (l'itérateur passé en paramètre est associé à la plus grande association), l'itérateur vide est renvoyé. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00269">269</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9603ef84d6e9a24098b62e77b42b95fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a> iterateur_precedent_table </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="table_8h.html#a5c6278d7df5951aa5f48522a0d279c68">Table_iterateur</a>&#160;</td>
          <td class="paramname"><em>iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renvoie l'itérateur précédent. </p>
<p>C'est-à-dire, l'itérateur renvoyé est positionné sur une nouvelle association qui est la plus grande des associations plus petites que celle associée à l'itérateur passé en en paramètre.</p>
<p>Deux associations sont comparées en comparant leurs clés par la fonction de comparaison des clés de la table.</p>
<p>S'il n'y a pas d'itérateur précédent (l'itérateur passé en paramètre est associé à la plus petite association), l'itérateur vide est renvoyé. </p>

<p>Définition à la ligne <a class="el" href="table_8c_source.html#l00274">274</a> du fichier <a class="el" href="table_8c_source.html">table.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Généré par &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
